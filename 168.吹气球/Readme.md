# GondorFu
---
## 描述
有n个气球，编号为0到n-1，每个气球都有一个分数，存在nums数组中。每次吹气球i可以得到的分数为 nums[left] * nums[i] * nums[right]，left和right分别表示i气球相邻的两个气球。当i气球被吹爆后，其左右两气球即为相邻。要求吹爆所有气球，得到最多的分数。

## 样例
```
给出 [4, 1, 5, 10]
返回 270

nums = [4, 1, 5, 10] burst 1, 得分 4 * 1 * 5 = 20
nums = [4, 5, 10]    burst 5, 得分 4 * 5 * 10 = 200 
nums = [4, 10]       burst 4, 得分 1 * 4 * 10 = 40
nums = [10]          burst 10, 得分 1 * 10 * 1 = 10
总共的分数为 20 + 200 + 40 + 10 = 270
```

## 标签 
动态规划

## 解题思路
- 思路：
    
    首先将题目抽象为吹爆编号i到j的气球能够获得的分数，最后的结果就是dp[0,n-1].
	
	这样，假设最后吹爆k，j>=k>=i，那么状态转移方程
	dp[i,j] = dp[i, k-1] + nums[i-1]*nums[k]*nums[j+1] + dp[k+1, j]
	
	注意求解中最后吹爆第k个气球的所用的数
    
- 具体操作：

	为简化编程，在nums都为加上一个1。这样最后的结果在dp[1, n]中。














