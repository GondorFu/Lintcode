# GondorFu
---
## 描述
给出一个字符串（假设长度最长为1000），求出它的最长回文子串，你可以假定只有一个满足条件的最长回文串。

## 样例
```
给出字符串 "abcdzdcab"，它的最长回文子串为 "cdzdc"。
```

## 挑战 
O(n^2) 时间复杂度的算法是可以接受的，如果你能用 O(n) 的算法那自然更好。

## 标签 
字符串处理

## 解题思路
- 思路：
    
    首先通过在每个间隙中添加一个特殊字符来解决最后的结果字符串长度为奇或偶数的情况。
    
    接着考虑到从子串中间向两边进行遍历能够节省一半的时间复杂度。
    
    最后也是最难想的是我们可以利用之前求解的子串对称信息来辅助新的子串对称性的判断。比如当我们已经得到第10位的最长子串半径是6，说明s[5:9]==s[11:15]。而如果我们要判断第13位的最长子串长度时，我们可以直接看第7位的情况。如果maxlen(7)<3，说明我们没有必要再遍历第13位的情况了。
    
- 具体操作：

    首先在字符串每个空隙处添加'#'字符。然后通过中心向两边遍历来判断子串的回文长度。最后保存现找的所有子串中涉及最远位置的子串的位置和半径，当需要判断的子串中心位置在保存子串的范围内时，首次判断子串是否有可能具有更大的半径，如果可能则可以从以判断的半径长度开始向更远处判断，同时更新最远子串的位置和半径。最后将最长子串输出即可。














